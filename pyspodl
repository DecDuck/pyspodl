#!/usr/bin/python3

"""
pyspodl - a spotify downloader using librespot
"""

import os
import sys
import time
import base64

import tqdm
import toml
import requests

from mutagen.flac import Picture
from mutagen.oggvorbis import OggVorbis

from mutagen.oggvorbis import OggVorbisHeaderError
from mutagen.ogg import error

from librespot.core import Session
from librespot.metadata import TrackId
from librespot.audio.decoders import AudioQuality, VorbisOnlyAudioQuality


class ConfigError(Exception):
    """
    triggered when theres an issue with the config file
    """


def read_config():
    """
    read the config file and return the data
    """

    config_path = os.path.normpath("config.toml")

    try:
        with open(config_path, encoding="utf-8") as config_file:
            return toml.load(config_file)

    except FileNotFoundError:
        sys.exit(f'[read_config] Config file "{config_path}" not found.')


def get_config_value(section, key):
    """
    get value from config file
    """

    config = read_config()
    value = config.get(section).get(key)

    if value is None or (isinstance(value, str) and not value.strip()):
        raise ConfigError(
            f"[get_config_value] Value for '{key}' in section '{section}' is missing or blank."
        )

    return value


def generate_new_token():
    """
    tokens are not permament, they expire after an hour,
    so when invalid, regenerates a new one
    """

    client_id = get_config_value("account", "client_id")
    client_secret = get_config_value("account", "client_secret")

    resp = requests.post(
        "https://accounts.spotify.com/api/token",
        {
            "grant_type": "client_credentials",
            "client_id": client_id,
            "client_secret": client_secret,
        },
        timeout=10,
    ).json()

    config = read_config()

    if config:
        config["account"]["token"] = resp["access_token"]

        try:
            with open("config.toml", "w", encoding="utf-8") as f:
                toml.dump(config, f)

        except Exception as e:
            sys.exit(
                f"[generate_new_token] Error updating the configuration file: {e}\n\nManually update token from the config.toml file by yourself with: \"{resp['access_token']}\""
            )

    os.execv(sys.argv[0], sys.argv)
    # sys.exit("Re-run pyspodl")


def get_token():
    """
    gets the temporary saved token from the config file
    """

    try:
        token = get_config_value("account", "token")

    except ConfigError:
        generate_new_token()

    headers = {"Authorization": f"Bearer {token}"}
    resp = requests.get(
        "https://api.spotify.com/v1/search?q=home+resonance&type=track",
        headers=headers,
        timeout=10,
    )

    if resp.status_code == 401:
        generate_new_token()

    return token


def set_metadata(metadata, cover_image, filename):
    """
    set metadata to a file (these are ogg tags, not id3!)
    """

    file = OggVorbis(f"{filename}.ogg")

    for key, value in metadata.items():
        file[key] = str(value)

    try:
        resp = requests.get(cover_image["url"], timeout=10)
        picture = Picture()

        picture.data = resp.content
        picture.type = 17
        picture.mime = "image/jpeg"
        picture.width = cover_image["width"]
        picture.height = cover_image["height"]

        picture_data = picture.write()
        encoded_data = base64.b64encode(picture_data)
        vcomment_value = encoded_data.decode("ascii")

        file["metadata_block_picture"] = [vcomment_value]

    except requests.exceptions.RequestException:
        pass

    try:
        file.save()

    except (OggVorbisHeaderError, error):
        pass  # fuck you
        # seriously fuck it, idk why it happens


def get_session():
    """
    create a user session and return it
    """

    try:
        session = (
            Session.Builder()
            .user_pass(
                get_config_value("account", "email"),
                get_config_value("account", "password"),
            )
            .create()
        )

        return session

    except Exception as exc:
        sys.exit(
            f"[get_session] An issue occured while trying to create session:\n{exc}"
        )


def get_id_type_from_url(url):
    """
    get the id of the track or whatever, and the type of whatever (lol.)
    """

    return (url.split("/")[4].split("?")[0], url.split("/")[3])


class Downloader:
    """
    where the magic happens.
    """

    def __init__(self):
        """
        define some values i guess...?
        """

        self.session = get_session()

        self.premium_downloads = get_config_value("downloading", "premium_downloads")
        self.download_path = get_config_value("downloading", "download_path")
        self.set_metadata = get_config_value("downloading", "set_metadata")

    def get_track_urls(self, link):
        """
        get all tracks available in a playlist or album (spotify gives max 50 entries)
        """

        track_urls = []
        offset = 0
        limit = 100
        id_from_url = get_id_type_from_url(link)

        url = (
            f"https://api.spotify.com/v1/{id_from_url[1] + 's'}/{id_from_url[0]}/tracks"
        )

        while True:
            try:
                headers = {"Authorization": f"Bearer {get_token()}"}
                params = {"offset": offset, "limit": limit}

                response = requests.get(url, headers=headers, params=params, timeout=10)
                items = response.json().get("items", [])

                if not items:
                    break

                track_urls.extend(
                    # item["track"]["id"]
                    item["track"]["external_urls"]["spotify"]
                    for item in items
                    if "track" in item and item["track"]
                )

                offset += limit

            except requests.exceptions.RequestException as e:
                print(f"[get_track_urls] Error making request: {e}")
                break

        return track_urls

    def download_playlist_or_album(self, link):
        """
        download songs off an album or playlist, with timeout
        to avoid account ban...?
        """

        tracks = self.get_track_urls(link)

        for track in tracks:
            self.download_track(track)  # sends id

            try:
                time.sleep(get_config_value("downloading", "timeout"))

            except TypeError:
                sys.exit(
                    '[download_playlist_or_album] "timeout" from config file must be a number (without quotes).'
                )

    def download_track(self, url):
        """
        download an track
        """

        track_id = TrackId.from_uri(f"spotify:track:{get_id_type_from_url(url)[0]}")
        headers = {"Authorization": f"Bearer {get_token()}"}

        resp = requests.get(
            f"https://api.spotify.com/v1/tracks/{get_id_type_from_url(url)[0]}",
            headers=headers,
            timeout=10,
        ).json()

        artist = resp["artists"][0]["name"]  # artist
        track_title = resp["name"]  # title
        album_name = resp["album"]["name"]  # album
        album_release = resp["album"]["release_date"]  # date
        track_number = resp["track_number"]  # tracknumber
        cover_image = resp["album"]["images"][0]  # coverart, width, height

        if self.premium_downloads:
            stream = self.session.content_feeder().load(
                track_id, VorbisOnlyAudioQuality(AudioQuality.VERY_HIGH), False, None
            )

        else:
            stream = self.session.content_feeder().load(
                track_id, VorbisOnlyAudioQuality(AudioQuality.HIGH), False, None
            )

        filename_format = get_config_value("downloading", "track_format")
        filename = filename_format.format(
            artist=artist,
            title=track_title,
            album=album_name,
            tracknumber=track_number,
            year=album_release,
        )

        print(f"Downloading {track_title} by {artist}")

        path_filename = os.path.normpath(f"{self.download_path}{os.sep}{filename}")

        if os.path.exists(path_filename + ".ogg"):
            print("Track exists, skipping")

        else:
            directory_path = os.path.dirname(path_filename)

            if directory_path and not os.path.exists(directory_path):
                os.makedirs(directory_path)

            with open(f"{path_filename}.ogg", "wb+") as track_file, tqdm.tqdm(
                unit="B",
                unit_scale=True,
                unit_divisor=1024,
                total=stream.input_stream.size,
                bar_format="{percentage:3.0f}%|{bar:16}|{n_fmt} / {total_fmt} | {rate_fmt}, ETA {remaining}",
            ) as progress_bar:
                for _ in range(int(stream.input_stream.size / 5000) + 1):
                    progress_bar.update(
                        track_file.write(stream.input_stream.stream().read(50000))
                    )

            if self.set_metadata:
                tags = {
                    "artist": artist,
                    "title": track_title,
                    "album": album_name,
                    "date": album_release,  # .split("-")[0],
                    "tracknumber": track_number,
                }

                set_metadata(tags, cover_image, path_filename)

    def download(self, link):
        """
        execute the function based on the link
        """

        link_type = get_id_type_from_url(link)[1]

        if link_type == "track":
            self.download_track(link)
            sys.exit()

        if link_type in ("album", "playlist"):
            self.download_playlist_or_album(link)
            sys.exit()

        else:
            sys.exit('[download] Invalid URL. URL must start with "open.spotify.com"')


if __name__ == "__main__":
    if len(sys.argv) == 1:
        sys.exit(
            "pyspodl - a spotify downloader using librespot\n   Usage: pyspodl LINK\n Example: pyspodl https://open.spotify.com/album/2nLOHgzXzwFEpl62zAgCEC?si=hHoYDm8dS-KVd6ZlCNvYoA&context=spotify%3Aalbum%3A2nLOHgzXzwFEpl62zAgCEC"
        )

    else:
        downloader = Downloader()
        link = sys.argv[1]

        downloader.download(link)
